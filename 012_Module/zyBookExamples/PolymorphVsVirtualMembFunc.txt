/* 12.7 Polymorphism and virtual member functions
Polymorphism
Polymorphism refers to determining which program behavior to execute depending on data types. Two main types of polymorphism exist:

Compile-time polymorphism is when the compiler determines which function to call at compile-time.
Runtime polymorphism is when the compiler is unable to determine which function to call at compile-time, so the determination is made while the program is running.
Function overloading is an example of compile-time polymorphism where the compiler determines which of several identically-named functions to call based on the function's arguments.

One scenario requiring runtime polymorphism involves derived classes. Programmers commonly create a collection of objects of both base and derived class types. Ex: The statement vector<Business*> businessList; creates a vector that can contain pointers to objects of type Business or Restaurant, since Restaurant is derived from Business. Similarly, polymorphism is also used for references to objects. Ex: Business& primaryBusiness declares a reference that can refer to Business or Restaurant objects. */

// compile-time polymorphism
void DriveTo(string restaurant) {
   cout << "Driving to " << restaurant << endl;
}

void DriveTo(Restaurant restaurant) {
   cout << "Driving to " << restaurant.GetDescription() << endl;
}

int main() {
   DriveTo("Big Mac's");  // Call string version
}

// runtime polymorphism
void DriveTo(Business* businessPtr) {
   cout << "Driving to " << businessPtr->GetDescription() << endl;
}

int main() {
   int index;
   vector<Business*> businessList;
   Business* businessPtr;
   Restaurant* restaurantPtr;
   ...
   businessList.push_back(businessPtr);
   businessList.push_back(restaurantPtr);

   index = rand() % businessList.size();
   DriveTo(businessList.at(index));
}


/* Virtual functions
Runtime polymorphism only works when an overridden member function in a base class is virtual. A virtual function is a member function that may be overridden in a derived class and is used for runtime polymorphism. A virtual function is declared by prepending the keyword "virtual". Ex: virtual string GetDescription() const. At runtime, when a virtual function is called using a pointer, the correct function to call is dynamically determined based on the actual object type to which the pointer or reference refers.

The override keyword is an optional keyword used to indicate that a virtual function is overridden in a derived class. Good practice is to use the override keyword when overriding a virtual function to avoid accidentally misspelling the function name or typing the wrong parameters. 


The program below illustrates how runtime polymorphism is used with a vector. businessList is a vector of Business pointers but holds Business and Restaurant pointers. A for loop iterates over businessList and calls each Business pointer's GetDescription() function. Restaurant GetDescription() is called when a Restaurant pointer is accessed because GetDescription() overrides the base class's virtual function.

Figure 12.7.1: Runtime polymorphism via a virtual function.

*/

#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Business {
public:
   void SetName(string busName) {
      name = busName;
   }

   void SetAddress(string busAddress) {
      address = busAddress;
   }

   virtual string GetDescription() const {
      return name + " -- " + address;
   }

protected:
   string name;
   string address;
};

class Restaurant : public Business {
public:
   void SetRating(int userRating) {
      rating = userRating;
   }

   int GetRating() const {
      return rating;
   }

   string GetDescription() const override {
      return name + " -- " + address +
         "\n  Rating: " + to_string(rating);
   }

private:
   int rating;
};

int main() {
   unsigned int i;
   vector<Business*> businessList;
   Business* businessPtr;
   Restaurant* restaurantPtr;

   businessPtr = new Business;
   businessPtr->SetName("ACME");
   businessPtr->SetAddress("4 Main St");

   restaurantPtr = new Restaurant;
   restaurantPtr->SetName("Friends Cafe");
   restaurantPtr->SetAddress("500 2nd Ave");
   restaurantPtr->SetRating(5);

   businessList.push_back(businessPtr);
   businessList.push_back(restaurantPtr);

   for (i = 0; i < businessList.size(); ++i) {
      cout << businessList.at(i)->GetDescription() << endl;
   }

   return 0;
}

/* Pure virtual functions
Sometimes a base class should not provide a definition for a member function, but all derived classes must provide a definition. Ex: A Business may require all derived classes to define a GetHours() function, but the Business class does not provide a default GetHours() function.

A pure virtual function is a virtual function that provides no definition in the base class, and all derived classes must override the function. A pure virtual function is declared like a virtual function with the "virtual" keyword but is assigned with 0. Ex: virtual string GetHours() const = 0; declares a pure virtual function GetHours().

A class that has at least one pure virtual function is known as an abstract base class. An abstract base class object cannot be declared. Ex: The variable declaration Business someBusiness; generates a syntax error if Business is an abstract base class.

Figure 12.7.2: Business is an abstract base class. */

class Business {
public:
   void SetName(string busName) {
      name = busName;
   }

   void SetAddress(string busAddress) {
      address = busAddress;
   }

   virtual string GetDescription() const {
      return name + " -- " + address;
   }

   virtual string GetHours() const = 0;     // pure virtual function

protected:
   string name;
   string address;
};

/* In the above example, the programmer may intend to create several classes derived from Business, such as Restaurant, LawnService, and CoffeeShop. The abstract base class Business implements functionality common to all derived classes, thus avoiding redundant code in all derived classes, and supporting uniform treatment of a collection (e.g., vector) of objects of derived classes via polymorphism. Not overriding the pure virtual function in a derived class makes the derived class an abstract base class too. 


12.7.5: Pure virtual functions.
*/

class GenericItem {
public:
   void SetName(string newName) {
      itemName = newName;
   }

   void PrintItem() const {
      cout << itemName << endl;
   }

protected:
   string itemName;
};

class ProduceItem : public GenericItem {
public:
   void SetExpiration(string newDate) {
      expirationDate = newDate;
   }
        
   void PrintItem() const {
      cout << itemName << " (expires " << expirationDate << ")" << endl;
   }

private:
   string expirationDate;
};

void PrintAllItems(const vector<GenericItem*> &items) {
   unsigned int i;
   for (i = 0; i < items.size(); ++i) {
      // Missing code
   }
}



